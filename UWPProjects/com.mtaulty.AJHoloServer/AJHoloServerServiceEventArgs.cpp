//-----------------------------------------------------------------------------
// <auto-generated>
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated.
//
//   For more information, see: http://go.microsoft.com/fwlink/?LinkID=623246
// </auto-generated>
//-----------------------------------------------------------------------------
#include "pch.h"

using namespace concurrency;
using namespace Microsoft::WRL;
using namespace Platform;
using namespace Windows::Foundation;
using namespace Windows::Foundation::Collections;
using namespace Windows::Devices::AllJoyn;
using namespace com::mtaulty::AJHoloServer;
namespace com { namespace mtaulty { namespace AJHoloServer {

// Methods
AJHoloServerAddWorldAnchorCalledEventArgs::AJHoloServerAddWorldAnchorCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberAnchorId,
    _In_ uint32 interfaceMemberByteStart,
    _In_ uint32 interfaceMemberByteLength,
    _In_ bool interfaceMemberLastBlock,
    _In_ Windows::Foundation::Collections::IVectorView<byte>^ interfaceMemberAnchorData)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberAnchorId(interfaceMemberAnchorId),
    m_interfaceMemberByteStart(interfaceMemberByteStart),
    m_interfaceMemberByteLength(interfaceMemberByteLength),
    m_interfaceMemberLastBlock(interfaceMemberLastBlock),
    m_interfaceMemberAnchorData(interfaceMemberAnchorData)
{
    m_result = AJHoloServerAddWorldAnchorResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ AJHoloServerAddWorldAnchorCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &AJHoloServerAddWorldAnchorCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void AJHoloServerAddWorldAnchorCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void AJHoloServerAddWorldAnchorCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void AJHoloServerAddWorldAnchorCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for AddWorldAnchorCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

AJHoloServerAddHologramToAnchorCalledEventArgs::AJHoloServerAddHologramToAnchorCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberAnchorId,
    _In_ Platform::String^ interfaceMemberHoloId,
    _In_ Platform::String^ interfaceMemberHoloTypeName,
    _In_ AJHoloServerPosition^ interfaceMemberPosition)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberAnchorId(interfaceMemberAnchorId),
    m_interfaceMemberHoloId(interfaceMemberHoloId),
    m_interfaceMemberHoloTypeName(interfaceMemberHoloTypeName),
    m_interfaceMemberPosition(interfaceMemberPosition)
{
    m_result = AJHoloServerAddHologramToAnchorResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ AJHoloServerAddHologramToAnchorCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &AJHoloServerAddHologramToAnchorCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void AJHoloServerAddHologramToAnchorCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void AJHoloServerAddHologramToAnchorCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void AJHoloServerAddHologramToAnchorCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for AddHologramToAnchorCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

AJHoloServerRemoveHologramCalledEventArgs::AJHoloServerRemoveHologramCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberHoloId)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberHoloId(interfaceMemberHoloId)
{
    m_result = AJHoloServerRemoveHologramResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ AJHoloServerRemoveHologramCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &AJHoloServerRemoveHologramCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void AJHoloServerRemoveHologramCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void AJHoloServerRemoveHologramCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void AJHoloServerRemoveHologramCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for RemoveHologramCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

AJHoloServerGetWorldAnchorCalledEventArgs::AJHoloServerGetWorldAnchorCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberAnchorId,
    _In_ uint32 interfaceMemberByteIndex,
    _In_ uint32 interfaceMemberByteLength)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberAnchorId(interfaceMemberAnchorId),
    m_interfaceMemberByteIndex(interfaceMemberByteIndex),
    m_interfaceMemberByteLength(interfaceMemberByteLength)
{
    m_result = AJHoloServerGetWorldAnchorResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ AJHoloServerGetWorldAnchorCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &AJHoloServerGetWorldAnchorCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void AJHoloServerGetWorldAnchorCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void AJHoloServerGetWorldAnchorCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void AJHoloServerGetWorldAnchorCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetWorldAnchorCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

AJHoloServerGetWorldAnchorIdsCalledEventArgs::AJHoloServerGetWorldAnchorIdsCalledEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
    m_result = AJHoloServerGetWorldAnchorIdsResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ AJHoloServerGetWorldAnchorIdsCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &AJHoloServerGetWorldAnchorIdsCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void AJHoloServerGetWorldAnchorIdsCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void AJHoloServerGetWorldAnchorIdsCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void AJHoloServerGetWorldAnchorIdsCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetWorldAnchorIdsCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

AJHoloServerGetHologramIdsAndNamesCalledEventArgs::AJHoloServerGetHologramIdsAndNamesCalledEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
    m_result = AJHoloServerGetHologramIdsAndNamesResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ AJHoloServerGetHologramIdsAndNamesCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &AJHoloServerGetHologramIdsAndNamesCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void AJHoloServerGetHologramIdsAndNamesCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void AJHoloServerGetHologramIdsAndNamesCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void AJHoloServerGetHologramIdsAndNamesCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetHologramIdsAndNamesCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

AJHoloServerGetHologramTransformsCalledEventArgs::AJHoloServerGetHologramTransformsCalledEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
    m_result = AJHoloServerGetHologramTransformsResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ AJHoloServerGetHologramTransformsCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &AJHoloServerGetHologramTransformsCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void AJHoloServerGetHologramTransformsCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void AJHoloServerGetHologramTransformsCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void AJHoloServerGetHologramTransformsCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetHologramTransformsCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

// Readable Properties
AJHoloServerGetDeviceConnectedCountRequestedEventArgs::AJHoloServerGetDeviceConnectedCountRequestedEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
    m_result = AJHoloServerGetDeviceConnectedCountResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ AJHoloServerGetDeviceConnectedCountRequestedEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &AJHoloServerGetDeviceConnectedCountRequestedEventArgs::Complete);
    return ref new Deferral(handler);
}

void AJHoloServerGetDeviceConnectedCountRequestedEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void AJHoloServerGetDeviceConnectedCountRequestedEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void AJHoloServerGetDeviceConnectedCountRequestedEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetDeviceConnectedCountRequested.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

// Writable Properties
} } } 
